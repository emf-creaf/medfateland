---
title: "Spatially-uncoupled simulations"
author: "Miquel De Caceres"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: TRUE
vignette: >
  %\VignetteIndexEntry{Spatially-uncoupled simulations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignettePackage{medfateland}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(medfate)
library(medfateland)
library(meteoland)
```

## Aim

The aim of this vignette is to illustrate how to use **medfateland** (v. `r packageVersion("medfateland")`) to carry out simulations of forest function and dynamics on a set of spatial units, without taking into account spatial processes. This is done using functions `spwb_spatial()`, `growth_spatial()` and `fordyn_spatial()`; which are counterparts of functions `spwb()`, `growth()` and `fordyn()` in package **medfate**. As an example, we will use function `spwb_spatial()`, but the other two functions would be used similarly.

## Preparation

### Input structures

We begin by loading an example data set of 100 forest stands distributed on points in the landscape:

```{r, fig.align='center', fig.width=7}
data("example_ifn")
example_ifn
```

### Displaying properties of spatial objects

Using `plot_variable()` functions for spatial landscape objects, we can draw maps of some variables using:

```{r, fig.align='center', fig.width=7}
plot_variable(example_ifn, "basal_area")
```

The set of maps available can be known by inspecting the help of function `extract_variables()`. Alternatively, the package provides function `shinyplot_land()` to display maps interactively.

## Carrying out simulations

As you should already know, package `medfate` includes functions `spwb()`, `growth()` and `fordyn()` to simulate soil water balance, carbon balance and forest dynamics on a single forest stand, respectively. This section describe how to run simulations on a set of forest stands in one call.  

As an example, we will use function `spwb_spatial()`, which simulates soil plant water balance on forests distributed in particular locations. The function takes an object of class `sf` as input.

### Weather inputs and local control parameters

As before, we need meteorological data, species parameters and control parameters for local simulations (which will apply to all forest stands):

```{r}
data("examplemeteo")
data("SpParamsMED")
local_control <- defaultControl()
```

### Calling the simulation function

The call to `spwb_spatial()` can be done as follows (here we restrict the dates for simplicity):
```{r, warning=FALSE}
dates <- seq(as.Date("2001-01-01"), as.Date("2001-02-28"), by="day")
res <- spwb_spatial(example_ifn, SpParamsMED, examplemeteo, 
                  dates = dates, local_control = local_control,  progress = FALSE)
```

Function `spwb_spatial()` first initializes model inputs by calling `forest2spwbInput()` for each forest stand described in the `sf` landscape object.  Then it calls function `spwb()` for each forest stand and stores the result. The fact that we used `examplemeteo` as meteorological input involves that the same weather was applied to all forest stands, but different weather could have been specified for each one (see documentation of function `spwb_spatial()`).

The result of calling `spwb_spatial()` is an object of class `sf` with the following columns:

```{r}
names(res)
```

Column `geometry` contains the geometry given as input to simulations, column `id` contains the identification label of each stand, column `state` contains the `spwbInput` corresponding to each forest stand (which can be used in subsequent simulations) and column `result` contains the output of `spwb()` function for each forest stand (i.e. its elements are objects of the S3 class `spwb`). 

### Temporal summaries, plots and maps

The structure of the output of `spwb_spatial()` allows querying information for the simulation of any particular forest stand. For example, we may use function `plot.spwb()`, from package **medfate**, to display the simulation results on a particular plot:
```{r, fig.width=7}
plot(res$result[[1]], "Evapotranspiration")
```

Similarly, if we want a monthly summary of water balance for the first stand, we can use function `summary.spwb()` from package **medfate**:

```{r}
summary(res$result[[1]], freq="months",FUN=sum, output="WaterBalance")
```

However, a more convenient way of generating summaries is by calculating them on all forest stands in one step, using function `simulation_summary()` on objects issued from simulations:

```{r}
res_sum <- simulation_summary(res, summary_function = summary.spwb, 
                              freq="months", output="WaterBalance")
```
where the argument `summary_function` points to the function to be used to generate local summaries and the remaining arguments are those of the local summary function. The result of using `simulation_summary()` is again an object of class `sf` that contains the spatial geometry and the list of summaries for all stands:
```{r}
names(res_sum)
```
The summary for the first stand can now be accessed through the first element of column `summary`:
```{r}
res_sum$summary[[1]]
```

Summary objects are handy because their `plot_summary()` function allows us to display maps of summaries for specific dates:
```{r, fig.align='center', fig.width=7}
plot_summary(res_sum, "Transpiration", "2001-01-01", limits=c(0,45))
plot_summary(res_sum, "Transpiration", "2001-02-01", limits=c(0,45))
```

To avoid displaying maps one by one, the package includes function `shinyplot_land()` that allows displaying maps of temporal summaries interactively.

### Simulation with integrated temporal summaries

If one needs to save memory, it is possible with `spwb_spatial()` to generate temporal summaries automatically after the simulation of soil water balance of each stand, and storing those summaries instead of all the output of function `spwb()`. 

For example the following code will keep temporal summaries of water balance components instead of simulation results: 

```{r, warning=FALSE}
res_2 <- spwb_spatial(example_ifn, SpParamsMED, examplemeteo, 
                  dates = dates, local_control = local_control,                  
                  keep_results = FALSE, progress = FALSE,
                  summary_function = summary.spwb, summary_arguments = list(freq="months"))
```

Parameter `keep_results = FALSE` tells `spwb_spatial()` not to keep the simulation results of forest stands, whereas `summary_function = summary.spwb` tells `spwb_spatial()` to perform and store summaries before discarding the results of any stand. The output has slightly different column names:

```{r}
names(res_2)
```

In particular, `result` is not included. Now the temporal summaries can be directly accessed through the column `summary`:
```{r}
res_2$summary[[1]]
```

And one can produce maps with summary results directly from the output of the simulation function:
```{r, fig.align='center', fig.width=7}
plot_summary(res_2, "Transpiration", "2001-02-01", limits=c(0,45))
```

The possibility of running a summary function after the simulation of each stand is not limited to `summary.spwb()`. Users can define their own summary functions, provided the first argument is `object`, which will contain the result of the simulation (i.e., the result of calling `spwb()`, `growth()` or `fordyn()`). For example, the following function calls `droughtStress()`:

```{r}
f_stress <- function(object, ...) {
  return(droughtStress(object, ..., draw = FALSE))
}
```

Now we can call again `spwb_spatial`:
```{r, warning=FALSE}
# res_3 <- spwb_spatial(example_ifn, SpParamsMED, examplemeteo, 
#                   dates = dates, local_control = local_control,                  
#                   keep_results = FALSE, progress = FALSE,
#                   summary_function = f_stress, 
#                   summary_arguments = list(index = "ADS", freq = "months", bySpecies=TRUE))
```

The drought stress summary of stand #1 is:
```{r}
# res_3$summary[[1]]
```

And we can draw a map with the monthly drought stress of *Quercus ilex* across space using:

```{r, fig.align='center', fig.width=7}
# plot_summary(res_3, "Quercus ilex", "2001-02-01")
```


## Continuing a previous simulation

The result of a simulation includes an element `state`, which stores the state of soil and stand variables at the end of the simulation. This information can be used to perform a new simulation from the point where the first one ended. In order to do so, we need to update the state variables in spatial object with their values at the end of the simulation, using function `update_landscape()`:

```{r}
example_ifn_mod <- update_landscape(example_ifn, res)
```

The resulting object `w` is the same as `y` except for the state variables. For example we can compare the water potential in the first soil layer:

```{r, fig.align='center', fig.width=7}
# plot_variable(example_ifn, "psi1")
plot_variable(example_ifn_mod, "psi1")
```

By using `w` as input we can now simulate water balance in the set of stands for an extra month:

```{r, warning=FALSE}
dates <- seq(as.Date("2001-03-01"), as.Date("2001-03-31"), by="day")
res_3 <- spwb_spatial(example_ifn_mod, SpParamsMED, examplemeteo, 
                      dates = dates, local_control = local_control, 
                      summary_function = summary.spwb, summary_arguments = list(freq = "months"),
                      progress = FALSE)
```

And display a map with the resulting month transpiration:

```{r, fig.align='center', fig.width=7}
plot_summary(res_3, "Transpiration", "2001-03-01", limits=c(0,45))
```
