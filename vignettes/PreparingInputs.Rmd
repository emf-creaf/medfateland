---
title: "Preparing inputs"
author: "Miquel De Cáceres / Núria Aquilué"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: TRUE
vignette: >
  %\VignetteIndexEntry{Preparing inputs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Aim

This vignette has been created to illustrate the creation of spatial inputs to be used in model simulations with the package, starting from a set of coordinates. The functions introduced in this document are meant to be executed sequentially to progressively add spatial information, but users are free to use them in the most convenient way.

Before reading this vignette, users should be familiar with *forest* and *soil* structures in package **medfate**. Moreover, a brief introduction to spatial structures used in **medfateland** package is given in  vignette [Package overview](https://emf-creaf.github.io/medfateland/articles/PackageOverview.html) and examples are given in vignettes [Spatially-uncoupled simulations](https://emf-creaf.github.io/medfateland/articles/SpatiallyUncoupledSimulations.html) and [Watershed simulations](https://emf-creaf.github.io/medfateland/articles/WatershedSimulations.html). 

Let's first load necessary libraries.

```{r}
library(medfate)
library(medfateland)
library(ggplot2)
library(tidyterra)
```

## Target coordinates

Any spatial data set should begin with the definition of spatial elements. Here we will use a watershed in Catalonia as example, which we will describe using cells of 100 m in EPSG:32631 (UTM for fuse 31) projection.

First we load a polygon data set describing watersheds in Spain and select our target watershed (Riera de Bianya [river code "2005528"]):
```{r}
dataset_path <- "~/OneDrive/EMF_datasets/"
scchh <- terra::vect(paste0(dataset_path, "Hydrography/Sources/Spain/CuencasMedNorte_Pfafs/M_cuencas_rios_Med_Norte.shp"))
watershed <-terra::project(scchh[scchh$pfafrio =="2005528",], "epsg:25831")
watershed
```

We can draw a map with the location of the watershed within Catalonia using:

```{r}
dataset_path <- "~/OneDrive/EMF_datasets/"
counties <- terra::vect(paste0(dataset_path, "PoliticalBoundaries/Sources/Catalunya/Comarques/comarques.shp"))
ggplot()+
  geom_spatvector(data = counties)+
  geom_spatvector(fill = "black", data = watershed)+
  theme_bw()
```


```{r, include = FALSE}
rm(scchh)
rm(counties)
gc()
```

Now we define a raster at 200 m resolution, including the target area. We intersect it with the watershed boundaries to keep the target locations:

```{r, warning = FALSE}
res <- 200
r <-terra::rast(terra::ext(watershed), resolution = c(res,res), crs = "epsg:25831")
v <- terra::intersect(terra::as.points(r), watershed)
```

And finally we transform the result into a `sf` object:
```{r}
x <- sf::st_as_sf(v)[,"geometry"]
x
```

We will use the raster definition for plots.

## Topography and land cover type

Once an object `sf` has been defined with target locations, we need to determine topographic features (elevation, slope, aspect) and land cover corresponding to those locations. You should have access to a Digital Elevation Model (DEM) at a desired resolution. Here we will use a DEM raster for Catalonia at 30 m resolution, which we load using package `terra`:

```{r}

dem <- terra::rast(paste0(dataset_path,"Topography/Products/Catalunya/MET30m_ETRS89_UTM31_ICGC.tif"))
dem
```

Similarly, you should have downloaded a land cover map, in this case we will use a land cover raster for Catalonia, issued in 2018:

```{r}
lcm <- terra::rast(paste0(dataset_path,"LandCover/Sources/Catalunya/cobertes-sol-v1r0-2018.tif"))
lcm
```

You should examine the legend of their land cover map and decide how to map legend elements to the five land cover types used in **medfateland**. After inspecting our land cover map legend, we define the following vectors to perform the legend mapping:

```{r}
agriculture <- 1:6
wildland <- c(7:17,20)
rock <- 18:19
artificial <- 21:35
water <- 36:41
```

Having these inputs, we can use function `create_landscape()` to add topographic and land cover features to our starting `sf`:
```{r}
y_1 <- create_landscape(x, dem = dem, land_cover_map = lcm, 
                        wildland = wildland, 
                        agriculture = agriculture, 
                        rock = rock, 
                        artificial = artificial, 
                        water = water, progress = FALSE)
```

We can examine the result using:
```{r}
y_1
```
```{r, echo = FALSE, include = FALSE}
rm(lcm)
gc()
```

We can now examine the elevation of the area, using the raster `r` to draw cells instead of points:

```{r, echo = FALSE, fig.width=6, fig.height=4.5}
plot_variable(y_1, "elevation", r = r)+
  scale_fill_distiller("m", palette="Spectral", na.value = NA)+
  theme_bw()
```

and the land cover types:

```{r, echo = FALSE, fig.width=6, fig.height=4.5}
plot_variable(y_1, "land_cover_type", r = r, name = "")
```

## Forest parameterization

The next step is to define `forest` objects for our simulations. Forests should be defined for all target locations whose land cover is defined as `wildland`. When forest inventory plots are not be available for the target locations, one must resort on imputations. 

  1. Forest inventory data from nearby locations. National forest inventories are ideal in this respect.
  2. A forest map where polygons or raster cells describe the distribution of forest (or shrubland) types. 
  3. Raster source of vegetation structure (i.e. mean tree height or basal area), derived from aerial or satellite LiDAR missions.

Our task here will be to perform imputations of forest inventory plots to our target locations according to some criteria and, if possible, to correct the forest structure on those locations according to available data.

### Forest imputation

A map of forest types in the target area is important to determine dominant tree or shrub species. We start by loading the Spanish Forest Map (1:25000) for the region of Catalonia, which is in vector format, using package `terra`:
```{r}
forest_map <- terra::vect(paste0(dataset_path,"ForestMaps/Products/Catalunya/mfe25_cat_class.shp"))
forest_map
```

Second, we need forest inventory data for imputations. Arguably, this is the hardest part. Let's assume one has access to a such data already in format for package *medfateland* (how to build such data set will be illustrated in a different vignette). We also load an `sf_nfi` object that contains coordinates and forest objects corresponding to the [Fourth Spanish Forest Inventory](https://www.miteco.gob.es/es/biodiversidad/temas/inventarios-nacionales/inventario-forestal-nacional/cuarto_inventario.html) for Catalonia (5509 forest plots):
```{r}
nfi_path <- "/home/miquel/OneDrive/mcaceres_work/model_initialisation/medfate_initialisation/IFN/"
sf_nfi <- readRDS(paste0(nfi_path, "Products/IFN4/Catalunya/IFN4_cat_final_ETRS89H31.rds"))
sf_nfi
```
Note that this is already an `sf` object suitable for simulations, but refers to the locations of the forest inventory plots, not to our target area.

Having these two inputs (forest map and forest inventory data), we can use function `impute_forests()` to perform the imputation for us (this normally takes some time):

```{r}
y_2 <- impute_forests(y_1, sf_nfi = sf_nfi, dem = dem, 
                      forest_map = forest_map, progress = FALSE)
```

For each target location, the function selects forest inventory plots that correspond to the same forest class, defined in the forest map, and are geographically closer than a pre-specified maximum distance. Among the multiple plots that can fulfill this criterion, the function chooses the plot that has the most similar elevation and position in the N-to-S slopes (i.e. the product of the cosine of aspect and slope). Warnings and errors can arise in the process. More details can be found in the documentation of `impute_forests()`.

The resulting `sf` has an extra column named `forest`:

```{r}
y_2
```

Only `wildland` locations will have a `forest` object, for example:

```{r}
y_2$forest[[1]]
```


### Structure correction

The former imputation result would be already useful for simulations, but the forest structure in the target locations can be very different than that of the forest inventory used as reference, even if the forest types are the same. Therefore, it is advisable to correct the forest structure with available information.

There are several global products made recently available, that combine satellite LiDAR observations with other information, such as [Simard et al. (2011)](https://doi.org/10.1029/2011JG001708), [Potapov et al. (2021)](https://doi.org/10.1016/j.rse.2020.112165) or [Lang et al. (2023)](https://doi.org/10.1038/s41559-023-02206-6). Alternatively, airborne LiDAR products are available for some countries and regions. Here we will use structural information derived from LiDAR flights in Catalonia (years 2016-2017). First we will load a mean tree height raster at 20-m resolution:

```{r}
height_map <- terra::rast(paste0(dataset_path, "RemoteSensing/Sources/Catalunya/Lidar/VariablesBiofisiques/RastersComplets/2016-2017/variables-biofisiques-arbrat-v1r0-hmitjana-2016-2017.tif"))
height_map
```

This resolution is a bit finer than the size of forest inventory plots. Hence, we aggregate the raster to the 40m resolution, while we crop to the target area:

```{r}
height_map_40 <- terra::aggregate(terra::crop(height_map, r), 
                                  fact = 2, fun = "mean", na.rm = TRUE)
height_map_40
```

Mean tree height data has the following distribution:
```{r, fig.width=6, fig.height=4}
names(height_map_40)<- "height"
ggplot()+
  geom_spatraster(aes(fill=height), data=height_map_40)+
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  scale_fill_continuous("m", type = "viridis", na.value = NA)+
  theme_bw()
```

We now call function `modify_forest_structure()` to correct mean tree height according to the LiDAR data (Note the correction of units: tree heights are in cm in **medfate**):

```{r}
height_map_40_cm <- height_map_40*100
y_3 <- modify_forest_structure(y_2, height_map_40_cm, var = "mean_tree_height",
                               progress = FALSE)
```

Correction of tree heights also affects tree diameters, because the function assumes that the diameter-height relationship needs to be preserved. If we inspect the same `forest` object again, we will be able to note changes in height and diameter values:

```{r}
y_3$forest[[1]]
```

Additionally, one may have access to other maps of structural variables. In our case, we will use a raster of basal area, also derived from LiDAR flights:

```{r}
basal_area_map <- terra::rast(paste0(dataset_path, "RemoteSensing/Sources/Catalunya/Lidar/VariablesBiofisiques/RastersComplets/2016-2017/variables-biofisiques-arbrat-v1r0-ab-2016-2017.tif"))
basal_area_map
```

We perform the same aggregation done for heights:

```{r}
basal_area_map_40 <- terra::aggregate(terra::crop(basal_area_map, r), 
                                      fact = 2, fun = "mean", na.rm = TRUE)
basal_area_map_40
```

Basal area geographic distribution looks as follows:

```{r, fig.width=6, fig.height=4}
names(basal_area_map_40)<- "basal_area"
ggplot()+
  geom_spatraster(aes(fill=basal_area), data=basal_area_map_40)+
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  scale_fill_continuous("m2/ha", type = "viridis", na.value = NA, limits = c(0,70))+
  theme_bw()
```

We now use the same function to correct basal area values (no unit conversion is needed in this case): 

```{r}
y_4 <- modify_forest_structure(y_3, basal_area_map_40, var = "basal_area",
                               progress = FALSE)
```

Note that basal area (or tree density) corrections should be done after the height correction, because of the effect that height correction has on tree diameters. The correction of basal area operates on tree density values. As before, we can inspect changes in tree density:

```{r}
y_4$forest[[1]]
```


To finish this section, we will show the effect of imputation and correction on structural variables, compared with the LiDAR data. 

```{r, echo = TRUE, fig.width=8, fig.height=5.5, warning = FALSE, message = TRUE}
p1 <- plot_variable(y_2, "basal_area", r = r)+
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  scale_fill_continuous("m2/ha", limits = c(0,70), type = "viridis", na.value = NA)+
  labs(title = "Imputation")+theme_bw()
p2 <- plot_variable(y_3, "basal_area", r = r)+
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  scale_fill_continuous("m2/ha", limits = c(0,70), type = "viridis", na.value = NA)+
  labs(title = "Imputation + H correction")+theme_bw()
p3 <- plot_variable(y_4, "basal_area", r = r)+
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  scale_fill_continuous("m2/ha", limits = c(0,70), type = "viridis", na.value = NA)+
  labs(title = "Imputation + H/BA correction")+theme_bw()
x_vect <- terra::vect(sf::st_transform(sf::st_geometry(x), terra::crs(basal_area_map_40)))
x_vect$basal_area <- terra::extract(basal_area_map_40, x_vect)$basal_area
r_ba<-terra::rasterize(x_vect, r, field = "basal_area")
p4 <- ggplot()+
  geom_spatraster(aes(fill=last), data=r_ba)+
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  scale_fill_continuous("m2/ha", limits = c(0,70), type = "viridis", na.value = NA)+
  labs(title = "Basal area from Lidar")+
  theme_bw()
cowplot::plot_grid(p1, p2, p3, p4, nrow = 2, ncol = 2)
```
where it is apparent that both the height correction and the basal area correction have an effect in basal area. Note that the map after the two corrections differs from the LiDAR basal area in locations that have not been corrected because of missing LiDAR values (or missing tree data). We can quantitatively assess the relationship between predicted basal area and the observed one using:

```{r}
ba_4 <- extract_variables(y_4, "basal_area")$basal_area
cor.test(ba_4, x_vect$basal_area)
```

We can also see the effect of the imputation and correction on mean tree height:

```{r, echo = TRUE, fig.width=8, fig.height=5.5, warning = FALSE, message = TRUE}
p1 <- plot_variable(y_2, "mean_tree_height", r = r)+
  scale_fill_continuous("cm", limits = c(0,2600), type = "viridis", na.value = NA)+
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  labs(title = "Imputation")+
  theme_bw()
p2 <- plot_variable(y_3, "mean_tree_height", r = r)+
  scale_fill_continuous("cm", limits = c(0,2600), type = "viridis", na.value = NA)+
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  labs(title = "Imputation + H mean_tree_height")+
  theme_bw()
p3 <- plot_variable(y_4, "mean_tree_height", r = r)+
  scale_fill_continuous("cm", limits = c(0,2600), type = "viridis", na.value = NA)+
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  labs(title = "Imputation + H/BA correction")+
  theme_bw()

x_vect <- terra::vect(sf::st_transform(sf::st_geometry(x), terra::crs(height_map_40_cm)))
x_vect$height <- terra::extract(height_map_40_cm, x_vect)$height
r_ba<-terra::rasterize(x_vect, r, field = "height")
p4 <- ggplot()+
  geom_spatraster(aes(fill=last), data=r_ba)+
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  scale_fill_continuous("cm", limits = c(0,2600), type = "viridis", na.value = NA)+
  labs(title = "Mean tree height from Lidar")+
  theme_bw()
cowplot::plot_grid(p1, p2, p3, p4, nrow = 2, ncol = 2)
```
Here the basal area correction did not have any effect on mean tree height. The relationship between estimated and predicted mean tree height is:

```{r}
mth_4 <- extract_variables(y_4, "mean_tree_height")$mean_tree_height
cor.test(mth_4, x_vect$height)
```

## Soil parameterization

Soil information is most usually lacking for the target locations. Regional maps of soil properties may be available in some cases. Here we assume this information is not available, so that we resort to global products. In particular, we will use information provided in [SoilGrids](https://soilgrids.org/) at 250 m resolution. 

### SoilGrids 2.0 data

Function `add_soilgrids()` can perform queries using the REST API of SoilGrids, but this becomes problematic for multiple sites. Hence, we recommend downloading SoilGrid rasters for the target region and storing them in a particular format, so that function `add_soilgrids()` can read them (check the details of the function documentation). The extraction of SoilGrids data for our target cells is rather fast using this approach: 

```{r}
soilgrids_path = paste0(dataset_path,"Soils/Sources/Global/SoilGrids/Spain/")
y_5 <- add_soilgrids(y_4, soilgrids_path = soilgrids_path, progress = FALSE)
```

And the result has an extra column `soil`:
```{r}
y_5
```

The elements of the list are the usual data frames of soil properties in **medfate**:
```{r}
y_5$soil[[1]]
```


### Correction for soil depth

SoilGrids 2.0 does not provide information on soil depth, and rock fragment content is normally underestimated, which leads to an overestimation of water holding capacity. Function `modify_soils()` allows modifying soil definitions, if information is available for soil depth, depth to the (unaltered) bedrock, or both. Soil depth maps are not common in many regions, so here we will resort on a global product at 250m-resolution by  [Shangguan et al. (2017)](https://doi.org/10.1002/2016MS000686), which consists on three rasters:

```{r}
# Censored soil depth (cm)
bdricm <- terra::rast(paste0(dataset_path, "Soils/Sources/Global/SoilDepth_Shangguan2017/BDRICM_M_250m_ll.tif"))
# Probability of bedrock within first 2m [0-100]
bdrlog <- terra::rast(paste0(dataset_path, "Soils/Sources/Global/SoilDepth_Shangguan2017/BDRLOG_M_250m_ll.tif"))
# Absolute depth to bedrock (cm)
bdticm <- terra::rast(paste0(dataset_path, "Soils/Sources/Global/SoilDepth_Shangguan2017/BDTICM_M_250m_ll.tif"))
```

In order to accelerate raster manipulations, we crop the global rasters to the extent of the target area:

```{r}
x_vect <- terra::vect(sf::st_transform(sf::st_geometry(x), terra::crs(bdricm)))
x_ext <- terra::ext(x_vect)
bdricm <- terra::crop(bdricm, x_ext, snap = "out")
bdrlog <- terra::crop(bdrlog, x_ext, snap = "out")
bdticm <- terra::crop(bdticm, x_ext, snap = "out")
```


Censored soil depth is a poor product of actual soil depth, but we have observed a fairly good correlation between soil depth values in Catalonia and the probability of finding the bedrock within the first two meters. Hence, we multiply the two layers and use it as a (crude) estimate of soil depth, expressing it in mm:

```{r}
soil_depth_mm <- (bdricm$BDRICM_M_250m_ll*10)*(1 - (bdrlog$BDRLOG_M_250m_ll/100))
```

and we take the depth to bedrock as appropriate, but change its units to mm as well:

```{r}
depth_to_bedrock_mm <- bdticm*10
```

We can now call function `modify_soils()` with the two rasters to perform the correction of soil characteristics:

```{r}
y_6 <- modify_soils(y_5, 
                    soil_depth_map = soil_depth_mm, 
                    depth_to_bedrock_map = depth_to_bedrock_mm,
                    progress = FALSE)
```

In this case, the depth to bedrock values were deeper than 2m, so that only the soil depth map had an effect on the correction procedure. After the correction, the rock fragment content of the soil has changed substantially:

```{r}
y_6$soil[[1]]
```

We can compare the effect of the correction on the soil water capacity (in mm) by inspecting the following plots (note the change in magnitude and spatial pattern):


```{r, echo = TRUE, warning = FALSE, message = FALSE, fig.width=7, fig.height=8}
p1 <- plot_variable(y_5, "soilvolextract", r = r)+ 
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  scale_fill_distiller("mm", type = "seq", palette = "YlGnBu", direction = 1, na.value = NA)+
  labs(title="SoilGrids alone")+
  theme_bw()
p2 <- plot_variable(y_6, "soilvolextract", r = r)+ 
  geom_spatvector(fill = NA, col = "black", linewidth = 0.5, data = watershed)+
  scale_fill_distiller("mm", type = "seq", palette = "YlGnBu", direction = 1, na.value = NA)+
  labs(title="SoilGrids + depth correction")+
  theme_bw()
cowplot::plot_grid(p1, p2, ncol =1, nrow=2)
```

## Initialization test

We can check whether the input data set is well formed by calling function  `initialize_landscape()`:

```{r}
z <- initialize_landscape(y_6, SpParamsMED, defaultControl(),
                          progress = FALSE)
```


Other variables may be needed, depending on the simulation function we want to use (crop factors, bedrock conductivity and porosity, etc.), but here we illustrated the most important ones.
